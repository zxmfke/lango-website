# 泛型状态图

<cite>
**本文档引用的文件**
- [main.go](file://examples/generic_state_graph/main.go)
- [state_graph_typed.go](file://graph/state_graph_typed.go)
- [state_graph.go](file://graph/state_graph.go)
- [schema_typed.go](file://graph/schema_typed.go)
- [schema.go](file://graph/schema.go)
- [listenable_example.go](file://examples/generic_state_graph_listenable/listenable_example.go)
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md)
</cite>

## 目录
1. [简介](#简介)
2. [核心概念](#核心概念)
3. [泛型状态图 API](#泛型状态图-api)
4. [状态模式与合并](#状态模式与合并)
5. [监听器与回调](#监听器与回调)
6. [示例分析](#示例分析)
7. [迁移指南](#迁移指南)
8. [最佳实践](#最佳实践)

## 简介

泛型状态图是 LangGraphGo 中的一项核心功能，它通过 Go 语言的泛型特性提供了编译时类型安全的状态管理。与传统的基于 `any` 类型的状态图相比，泛型状态图消除了运行时类型断言的需求，提供了更好的 IDE 支持和开发体验。本文档将深入探讨泛型状态图的设计、实现和使用方法。

**Section sources**
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md#摘要)
- [main.go](file://examples/generic_state_graph/main.go#L1-L244)

## 核心概念

### 类型安全

泛型状态图的核心优势在于类型安全。通过使用泛型类型参数，开发者可以在编译时捕获类型错误，避免了运行时因错误的类型断言而导致的 panic。这种类型安全不仅提高了代码的可靠性，还改善了开发体验。

### 泛型设计

泛型状态图的设计采用了双 API 策略，同时维护非泛型和泛型两个版本的 API。这种设计确保了向后兼容性，允许开发者逐步迁移到泛型版本。泛型版本通过类型参数 `S` 来指定状态类型，从而实现编译时类型检查。

### 迁移路径

迁移路径设计为渐进式，允许开发者在不破坏现有代码的情况下逐步采用泛型。迁移步骤包括识别状态类型、更改构造函数、更新节点函数、更新条件边和更新调用。

**Section sources**
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md#动机)
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md#迁移路径)

## 泛型状态图 API

### 构造函数

泛型状态图的构造函数 `NewStateGraphTyped[S any]()` 创建一个具有类型安全的 `StateGraphTyped[S]` 实例。类型参数 `S` 表示状态类型，通常是结构体。

```go
g := graph.NewStateGraphTyped[WorkflowState]()
```

### 节点定义

`AddNode` 方法允许添加带有类型化函数的节点。节点函数的签名是 `func(ctx context.Context, state S) (S, error)`，其中 `S` 是状态类型。这消除了类型断言的需要，提供了完全的类型安全。

```go
g.AddNode("check_age", "Check if user is adult", func(ctx context.Context, state WorkflowState) (WorkflowState, error) {
    state.IsAdult = state.Request.Age >= 18
    return state, nil
})
```

### 条件边

`AddConditionalEdge` 方法允许添加基于条件的边，其中条件函数的签名是 `func(ctx context.Context, state S) string`。这同样提供了类型安全，避免了类型断言。

```go
g.AddConditionalEdge("check_age", func(ctx context.Context, state WorkflowState) string {
    if state.IsAdult {
        return "adult_path"
    }
    return "minor_path"
})
```

### 编译与调用

`Compile` 方法返回一个 `StateRunnableTyped[S]` 实例，该实例可以使用类型化的状态进行调用。`Invoke` 方法的签名是 `func (r *StateRunnableTyped[S]) Invoke(ctx context.Context, initialState S) (S, error)`，确保了调用时的类型安全。

```go
app, err := g.Compile()
finalState, err := app.Invoke(context.Background(), initialState)
```

**Section sources**
- [state_graph_typed.go](file://graph/state_graph_typed.go#L59-L149)
- [main.go](file://examples/generic_state_graph/main.go#L50-L86)

## 状态模式与合并

### 状态模式

状态模式定义了状态的结构和更新逻辑。`StateSchemaTyped[S]` 接口提供了 `Init()` 和 `Update(current, new S) (S, error)` 方法，用于初始化和更新状态。

### 结构体模式

`StructSchema[S any]` 是一个具体的实现，用于基于结构体的状态。它允许定义初始值和合并函数，提供了灵活的状态管理。

```go
schema := graph.NewStructSchema(
    ProcessState{MaxCount: 5, Processing: true},
    func(current, new ProcessState) (ProcessState, error) {
        current.Items = append(current.Items, new.Items...)
        current.Count += new.Count
        return current, nil
    },
)
```

### 字段级合并

`FieldMerger[S any]` 提供了对结构体字段的细粒度控制。通过注册自定义的合并函数，可以精确控制每个字段的合并行为。

```go
fm := graph.NewFieldMerger[ProcessState](ProcessState{})
fm.RegisterFieldMerge("Items", graph.AppendSliceMerge)
fm.RegisterFieldMerge("Count", graph.SumIntMerge)
```

**Section sources**
- [schema_typed.go](file://graph/schema_typed.go#L8-L66)
- [main.go](file://examples/generic_state_graph/main.go#L180-L189)

## 监听器与回调

### 监听器接口

`NodeListener` 接口定义了节点事件的监听方法。`OnNodeEvent` 方法在节点事件发生时被调用，提供了对节点执行的细粒度控制。

### 监听器实现

`ListenableStateGraph` 扩展了 `StateGraph`，增加了监听器支持。通过 `AddGlobalListener` 方法，可以为所有节点添加全局监听器。

```go
workflow := graph.NewListenableStateGraphTyped[CounterState]()
logger := &EventLogger{}
workflow.AddGlobalListener(logger)
```

### 流式监听

`StreamingListenerTyped` 提供了流式监听功能，允许在执行过程中接收事件。这对于实时监控和调试非常有用。

```go
eventChan := streamingRunnable.Stream(context.Background(), initialState)
for event := range eventChan {
    // 处理事件
}
```

**Section sources**
- [listeners.go](file://graph/listeners.go#L51-L289)
- [listenable_example.go](file://examples/generic_state_graph_listenable/listenable_example.go#L60-L138)

## 示例分析

### 简单类型安全图

此示例展示了如何创建一个简单的类型安全图，通过 `NewStateGraphTyped[WorkflowState]()` 创建图，并添加节点和边。

```go
g := graph.NewStateGraphTyped[WorkflowState]()
g.AddNode("check_age", "Check age", func(ctx context.Context, state WorkflowState) (WorkflowState, error) {
    state.IsAdult = state.Request.Age >= 18
    return state, nil
})
```

### 条件路由

此示例展示了如何使用条件边进行条件路由。条件函数根据状态决定下一个节点。

```go
g.AddConditionalEdge("check_age", func(ctx context.Context, state WorkflowState) string {
    if state.IsAdult {
        return "adult_path"
    }
    return "minor_path"
})
```

### 使用模式进行状态合并

此示例展示了如何使用 `StructSchema` 进行复杂的状态合并。通过定义合并函数，可以实现自定义的合并逻辑。

```go
schema := graph.NewStructSchema(
    ProcessState{MaxCount: 5, Processing: true},
    func(current, new ProcessState) (ProcessState, error) {
        current.Items = append(current.Items, new.Items...)
        current.Count += new.Count
        return current, nil
    },
)
```

**Section sources**
- [main.go](file://examples/generic_state_graph/main.go#L44-L244)

## 迁移指南

### 识别状态类型

首先，识别现有代码中的状态类型。通常，状态类型是一个结构体，包含计数器、日志等字段。

### 更改构造函数

将 `NewStateGraph()` 更改为 `NewStateGraphTyped[S]()`，其中 `S` 是状态类型。

### 更新节点函数

将节点函数中的类型断言 `state.(MyState)` 替换为直接使用类型 `state MyState`。

### 更新条件边

将条件边中的类型断言 `state.(MyState)` 替换为直接使用类型 `state MyState`。

### 更新调用

将 `Invoke` 调用中的类型断言 `result.(MyState)` 替换为直接使用类型 `finalState, err := app.Invoke(ctx, initialState)`。

**Section sources**
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md#迁移路径)

## 最佳实践

### 使用结构体状态

推荐使用结构体作为状态类型，因为它提供了更好的类型安全和可读性。

### 定义清晰的合并逻辑

通过 `StructSchema` 或 `FieldMerger` 定义清晰的合并逻辑，确保状态更新的正确性。

### 利用监听器

利用监听器进行调试和监控，特别是在复杂的图中，监听器可以帮助理解执行流程。

### 渐进式迁移

采用渐进式迁移策略，逐步将现有代码迁移到泛型版本，确保平稳过渡。

**Section sources**
- [RFC_GENERIC_STATEGRAPH_CN.md](file://docs/GENERIC/RFC_GENERIC_STATEGRAPH_CN.md#权衡分析)
- [main.go](file://examples/generic_state_graph/main.go#L1-L244)