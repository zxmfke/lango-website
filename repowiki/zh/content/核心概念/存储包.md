# 存储包

<cite>
**本文档中引用的文件**   
- [doc.go](file://store/doc.go)
- [checkpoint.go](file://store/checkpoint.go)
- [file/doc.go](file://store/file/doc.go)
- [memory/doc.go](file://store/memory/doc.go)
- [postgres/doc.go](file://store/postgres/doc.go)
- [redis/doc.go](file://store/redis/doc.go)
- [sqlite/doc.go](file://store/sqlite/doc.go)
- [file/file.go](file://store/file/file.go)
- [memory/memory.go](file://store/memory/memory.go)
- [postgres/postgres.go](file://store/postgres/postgres.go)
- [redis/redis.go](file://store/redis/redis.go)
- [sqlite/sqlite.go](file://store/sqlite/sqlite.go)
- [durable_execution/main.go](file://examples/durable_execution/main.go)
- [file_checkpointing/main.go](file://examples/file_checkpointing/main.go)
</cite>

## 目录
1. [简介](#简介)
2. [核心概念](#核心概念)
3. [存储实现](#存储实现)
4. [使用模式](#使用模式)
5. [性能考虑](#性能考虑)
6. [最佳实践](#最佳实践)
7. [集成示例](#集成示例)

## 简介

存储包为 LangGraph Go 提供了持久化检查点和状态的存储实现。存储实现允许图执行在不同的运行、进程甚至不同机器之间持久化，从而实现中断工作流的恢复、复杂执行的调试以及分布式系统中的状态维护等功能。

该包提供了三种流行存储后端的实现：
- **SQLite**: 轻量级、无服务器的文件存储
- **PostgreSQL**: 健壮、可扩展的关系数据库
- **Redis**: 高性能内存存储

此外，还提供了文件系统和内存存储的实现，满足不同场景的需求。

**Section sources**
- [doc.go](file://store/doc.go#L1-L327)

## 核心概念

### 检查点

检查点捕获图执行在特定时间点的状态，包括：
- 当前正在执行的节点
- 完整的状态对象
- 执行元数据
- 时间戳和配置信息

这允许执行在完全相同的状态下暂停和稍后恢复。

### 存储接口

所有存储实现都遵循在 `graph` 包中定义的统一接口：

```go
type CheckpointStore interface {
    // 保存检查点
    Save(ctx context.Context, checkpoint *Checkpoint) error

    // 按ID检索检查点
    Load(ctx context.Context, checkpointID string) (*Checkpoint, error)

    // 列出指定执行的所有检查点
    List(ctx context.Context, executionID string) ([]*Checkpoint, error)

    // 删除检查点
    Delete(ctx context.Context, checkpointID string) error

    // 清除指定执行的所有检查点
    Clear(ctx context.Context, executionID string) error
}
```

### 检查点结构

检查点结构包含以下字段：
- **ID**: 检查点的唯一标识符
- **NodeName**: 当前执行的节点名称
- **State**: 图的完整状态对象
- **Metadata**: 元数据映射，用于存储额外信息
- **Timestamp**: 创建时间戳
- **Version**: 版本号，用于跟踪状态演变

**Section sources**
- [checkpoint.go](file://store/checkpoint.go#L8-L34)
- [doc.go](file://store/doc.go#L15-L21)

## 存储实现

### 文件存储 (store/file)

文件存储实现将检查点作为 JSON 文件存储在文件系统中。

**特点**:
- 简单的文件系统存储
- 适合开发和测试
- 无需外部依赖
- 支持并发访问的读写锁

**使用示例**:
```go
store, err := file.NewFileCheckpointStore("./checkpoints")
if err != nil {
    return err
}
defer store.Close()
```

**Section sources**
- [file/doc.go](file://store/file/doc.go#L1-L3)
- [file/file.go](file://store/file/file.go#L15-L168)

### 内存存储 (store/memory)

内存存储实现将检查点保存在内存中。

**特点**:
- 极快的读写性能
- 适合临时存储和测试
- 进程终止后数据丢失
- 支持线程安全操作

**使用示例**:
```go
store := memory.NewMemoryCheckpointStore()
```

**Section sources**
- [memory/doc.go](file://store/memory/doc.go#L1-L3)
- [memory/memory.go](file://store/memory/memory.go#L12-L101)

### PostgreSQL 存储 (store/postgres)

PostgreSQL 存储实现使用 PostgreSQL 数据库进行持久化存储。

**特点**:
- 健壮的持久化和可扩展性
- 支持复杂查询
- 连接池支持
- 高级索引功能
- JSONB 支持元数据

**使用示例**:
```go
store, err := postgres.NewPostgresCheckpointStore(ctx, postgres.PostgresOptions{
    ConnString: "postgres://user:password@localhost/langgraph",
})
```

**Section sources**
- [postgres/doc.go](file://store/postgres/doc.go#L1-L329)
- [postgres/postgres.go](file://store/postgres/postgres.go#L22-L250)

### Redis 存储 (store/redis)

Redis 存储实现使用 Redis 进行高速存储。

**特点**:
- 内存存储，可选持久化
- 自动 TTL（生存时间）过期
- 原子操作
- 支持发布/订阅通知
- 集群支持

**使用示例**:
```go
store := redis.NewRedisCheckpointStore(redis.RedisOptions{
    Addr: "localhost:6379",
    TTL:  24 * time.Hour,
})
```

**Section sources**
- [redis/doc.go](file://store/redis/doc.go#L1-L396)
- [redis/redis.go](file://store/redis/redis.go#L13-L211)

### SQLite 存储 (store/sqlite)

SQLite 存储实现使用 SQLite 数据库进行文件存储。

**特点**:
- 无服务器、文件型数据库
- ACID 事务支持
- 零配置需求
- 跨平台兼容性
- 支持全文搜索

**使用示例**:
```go
store, err := sqlite.NewSqliteCheckpointStore(sqlite.SqliteOptions{
    Path: "./checkpoints.db",
})
```

**Section sources**
- [sqlite/doc.go](file://store/sqlite/doc.go#L1-L402)
- [sqlite/sqlite.go](file://store/sqlite/sqlite.go#L13-L241)

## 使用模式

### 基本检查点

```mermaid
flowchart TD
Start["开始"] --> CreateGraph["创建图"]
CreateGraph --> ConfigureStore["配置存储"]
ConfigureStore --> EnableCheckpointing["启用检查点"]
EnableCheckpointing --> Execute["执行"]
Execute --> SaveCheckpoint["自动保存检查点"]
SaveCheckpoint --> Resume["恢复执行"]
Resume --> End["结束"]
```

**代码示例**:
```go
// 创建图
g := graph.NewStateGraph()
// ... 配置图 ...

// 选择并配置存储
store, err := sqlite.NewSqliteCheckpointStore(sqlite.SqliteOptions{
    Path: "./checkpoints.db",
})
if err != nil {
    return err
}
defer store.Close()

// 启用检查点
compileConfig := graph.CompileConfig{
    CheckpointConfig: graph.CheckpointConfig{
        Store: store,
    },
}

runnable, err := g.CompileWithOptions(compileConfig)

// 执行并自动检查点
result, err := runnable.Invoke(ctx, input,
    graph.WithExecutionID("unique-execution-id"))

// 从检查点恢复
resumed, err := runnable.Resume(ctx,
    "unique-execution-id",
    "checkpoint-to-resume-from")
```

**Section sources**
- [doc.go](file://store/doc.go#L117-L149)
- [file_checkpointing/main.go](file://examples/file_checkpointing/main.go#L13-L115)

### 持久化执行

持久化执行允许在进程崩溃或中断后恢复工作流。

```mermaid
sequenceDiagram
participant App as "应用程序"
participant Store as "存储"
participant Graph as "图执行器"
App->>Graph : 启动执行
Graph->>Store : 保存检查点
Store-->>Graph : 确认
Graph->>Graph : 执行节点
Note over Graph : 可能发生崩溃
App->>Graph : 重启并恢复
Graph->>Store : 加载最新检查点
Store-->>Graph : 返回检查点
Graph->>Graph : 从上次状态继续
Graph-->>App : 完成结果
```

**代码示例**:
```go
// 检查现有检查点以恢复
ctx := context.Background()
checkpoints, _ := store.List(ctx, threadID)

if len(checkpoints) > 0 {
    latest := checkpoints[len(checkpoints)-1]
    fmt.Printf("找到现有检查点: %s (节点: %s)\n", latest.ID, latest.NodeName)
    fmt.Println("恢复执行...")
    
    // 从检查点恢复
    result, err := runnable.Resume(ctx, "unique-execution-id", latest.ID)
}
```

**Section sources**
- [durable_execution/main.go](file://examples/durable_execution/main.go#L15-L200)

## 性能考虑

### 序列化

所有存储都使用 JSON 序列化检查点数据。为了获得最佳性能：
- 保持状态对象相对较小
- 避免在检查点中存储大型二进制数据
- 考虑对大型状态对象进行压缩

### 批量操作

某些存储支持批量操作以获得更好的性能：

```go
// 批量保存多个检查点
checkpoints := []*graph.Checkpoint{cp1, cp2, cp3}
err := store.PutBatch(ctx, checkpoints)
```

### 连接池

对于生产环境，建议使用连接池来提高性能和资源利用率。

**PostgreSQL 连接池**:
```go
pool, err := postgres.NewConnectionPool(ctx, postgres.PoolConfig{
    ConnString:      connString,
    MaxConns:        20,
    MinConns:        5,
    MaxConnLifetime: time.Hour,
})
```

**Redis 连接池**:
```go
rdb := redis.NewClient(&redis.Options{
    Addr:         "localhost:6379",
    PoolSize:     10,
    MinIdleConns: 5,
})
```

**Section sources**
- [doc.go](file://store/doc.go#L200-L213)
- [postgres/doc.go](file://store/postgres/doc.go#L73-L84)
- [redis/doc.go](file://store/redis/doc.go#L89-L102)

## 最佳实践

### 选择合适的存储

**使用 SQLite 当**:
- 需要简单、自包含的解决方案
- 应用程序在单台机器上运行
- 偏好零配置
- 需要在文件中存储检查点

**使用 PostgreSQL 当**:
- 需要健壮的持久化和可扩展性
- 应用程序需要复杂查询
- 有多个进程访问相同数据
- 需要企业级功能（备份、复制）

**使用 Redis 当**:
- 性能是主要关注点
- 需要旧检查点的自动过期
- 正在构建分布式系统
- 需要检查点更改的实时通知

### 错误处理

- 实现瞬态错误的重试逻辑
- 提供回退机制
- 记录检查点失败以进行调试
- 使用上下文超时防止无限等待

### 检查点生命周期管理

- 定期清理旧检查点
- 使用 TTL 进行自动清理（Redis）
- 实施保留策略
- 监控存储使用情况

### 安全考虑

- 在存储前加密敏感数据
- 使用安全的数据库连接
- 实施适当的访问控制
- 使用环境变量存储凭据
- 启用生产环境中的 SSL/TLS

**Section sources**
- [doc.go](file://store/doc.go#L216-L240)
- [postgres/doc.go](file://store/postgres/doc.go#L287-L296)
- [redis/doc.go](file://store/redis/doc.go#L336-L344)
- [sqlite/doc.go](file://store/sqlite/doc.go#L354-L362)

## 集成示例

### 与预建代理集成

```go
// 与 React 代理集成
agent := prebuilt.CreateReactAgent(llm, tools, 10,
    prebuilt.WithCheckpointing(graph.CheckpointConfig{
        Store: store,
    }),
)

// 与规划代理集成
planner, _ := prebuilt.CreatePlannerAgent(
    llm,
    tools,
    graph.WithCheckpointing(graph.CheckpointConfig{
        Store: store,
    }),
)
```

### 与自定义图集成

```go
// 与自定义图集成
g := graph.NewStateGraph()
g.WithCheckpointing(graph.CheckpointConfig{
    Store: store,
})
```

### 与流式执行集成

```go
// 与流式执行集成
streaming := graph.NewStreamingStateGraph(g, graph.StreamConfig{
    BufferSize: 100,
})
streaming.WithCheckpointing(graph.CheckpointConfig{
    Store: store,
})
```

**Section sources**
- [doc.go](file://store/doc.go#L242-L265)
- [postgres/doc.go](file://store/postgres/doc.go#L234-L260)
- [redis/doc.go](file://store/redis/doc.go#L288-L307)