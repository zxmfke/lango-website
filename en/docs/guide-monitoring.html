<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitoring & Debugging Guide - LangGraphGo Docs</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .doc-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 120px 2rem 4rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 3rem;
        }

        .sidebar {
            position: sticky;
            top: 120px;
            height: fit-content;
        }

        .sidebar-nav {
            list-style: none;
        }

        .sidebar-nav li {
            margin-bottom: 0.5rem;
        }

        .sidebar-nav a {
            color: var(--text-secondary);
            font-size: 0.95rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
        }

        .sidebar-nav a:hover,
        .sidebar-nav a.active {
            background: #eff6ff;
            color: var(--primary-color);
            font-weight: 500;
        }

        .content h1 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }

        .content h2 {
            font-size: 1.8rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
        }

        .content h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
        }

        .content p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .content :not(pre)>code {
            background: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Menlo', monospace;
            color: #c7254e;
        }

        .content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }

        .content pre {
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }
    </style>
</head>

<body>
    <header>
        <div class="nav-container">
            <a href="index.html" class="logo">
                <img src="images/logo/lango5.svg" alt="LangGraphGo Logo">
                LangGraphGo
            </a>
            <ul class="nav-links">
                <li><a href="../showcases.html">Showcases</a></li>
                <li><a href="../docs.html" style="color: var(--primary-color);">Docs</a></li>
                <li><a href="../examples.html">Examples</a></li>
                <li><a href="../../docs/guide-monitoring.html">中文</a></li>
            </ul>
            <a href="https://github.com/smallnest/langgraphgo" target="_blank" class="btn-github">
                <i class="fab fa-github"></i> GitHub
            </a>
        </div>
    </header>

    <div class="doc-container">
        <aside class="sidebar">
            <ul class="sidebar-nav">
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="core-concepts.html">Core Concepts</a></li>
                <li><a href="guides.html" class="active">Guides</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li
                    style="margin-top: 1.5rem; font-size: 0.85rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;">
                    Topic Guides</li>
                <li><a href="guide-basics.html" style="padding-left: 1rem;">Basic Building Blocks</a></li>
                <li><a href="guide-stategraph-vs-messagegraph.html" style="padding-left: 1rem;">StateGraph vs
                        MessageGraph</a></li>
                <li><a href="guide-createagent-vs-createreactagent.html" style="padding-left: 1rem;">CreateAgent vs
                        CreateReactAgent</a></li>
                <li><a href="guide-prebuilt-agents.html" style="padding-left: 1rem;">Prebuilt Agents</a></li>
                <li><a href="guide-streaming.html" style="padding-left: 1rem;">Streaming</a></li>
                <li><a href="guide-memory-timetravel.html" style="padding-left: 1rem;">Memory & Time Travel</a></li>
                <li><a href="guide-advanced-features.html" style="padding-left: 1rem;">Advanced Features</a></li>
                <li><a href="guide-rag.html" style="padding-left: 1rem;">RAG Pipeline</a></li>
                <li><a href="guide-hitl.html" style="padding-left: 1rem;">Human in the Loop (HITL)</a></li>
                <li><a href="guide-multi-agent.html" style="padding-left: 1rem;">Multi-Agent Systems</a></li>
                <li><a href="guide-state-management.html" style="padding-left: 1rem;">State Management</a></li>
                <li><a href="guide-monitoring.html" class="active" style="padding-left: 1rem;">Monitoring &
                        Debugging</a></li>
            </ul>
        </aside>
        <main class="content">
            <h1>Monitoring & Debugging</h1>
            <p>When running Agent systems in production, "black box" is the biggest enemy. You need to know what the
                Agent is doing, why it is doing it, and how to recover when things go wrong. LangGraphGo provides
                multi-level monitoring and debugging tools.</p>

            <h2>1. Listeners</h2>

            <h3>Background & Functionality</h3>
            <p>Listeners allow you to subscribe to graph lifecycle events in a non-intrusive way. You can monitor when
                nodes start, end, what the input is, what the output is, and whether an error occurred.</p>
            <p>This is very useful for integrating logging systems (like Zap, Logrus), distributed tracing (like
                OpenTelemetry), or real-time monitoring dashboards.</p>

            <h3>Implementation Principle</h3>
            <p>The runtime triggers events at key execution points (before node start, after node end, on error).
                Registered listener functions are called synchronously or asynchronously.</p>

            <h3>Code Showcase</h3>
            <pre><code class="language-go">// Define listener function
listener := func(event graph.Event) {
    switch event.Type {
    case graph.NodeStart:
        log.Printf("[START] Node: %s, Input: %v", event.Node, event.Input)
    case graph.NodeEnd:
        log.Printf("[END] Node: %s, Output: %v", event.Node, event.Output)
    case graph.Error:
        log.Printf("[ERROR] Node: %s, Err: %v", event.Node, event.Error)
    }
}

// Register listener
runnable.AddListener(listener)</code></pre>

            <h2>2. Durable Execution</h2>

            <h3>Background & Functionality</h3>
            <p>Agent tasks might run for a long time (minutes or even hours). If the process crashes or server restarts,
                we don't want to start from scratch. Durable execution allows tasks to automatically resume from the
                last successful Checkpoint.</p>

            <h3>Implementation Principle</h3>
            <p>This relies on the Checkpointing mechanism. Every state update is persisted. When the system restarts and
                resumes with the same ThreadID, it first loads the latest Checkpoint and continues execution from there.
            </p>

            <h3>Code Showcase</h3>
            <pre><code class="language-go">// 1. Get latest state
latestCheckpoint, err := store.GetLatest(threadID)

if latestCheckpoint != nil {
    // 2. If history exists, resume
    log.Println("Resuming from checkpoint...")
    runnable.ResumeFromCheckpoint(ctx, latestCheckpoint.ID)
} else {
    // 3. Otherwise start new
    log.Println("Starting new execution...")
    runnable.Invoke(ctx, input)
}</code></pre>

            <h2>3. Debugging Tools</h2>
            <p>Besides the above mechanisms, LangGraphGo also recommends combining standard Go debugging tools (like
                Delve) and profiling tools (pprof) to deeply analyze Agent behavior.</p>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="../../script.js"></script>
</body>

</html>