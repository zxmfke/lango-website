<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG Pipeline Guide - LangGraphGo Docs</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .doc-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 120px 2rem 4rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 3rem;
        }

        .sidebar {
            position: sticky;
            top: 120px;
            height: fit-content;
        }

        .sidebar-nav {
            list-style: none;
        }

        .sidebar-nav li {
            margin-bottom: 0.5rem;
        }

        .sidebar-nav a {
            color: var(--text-secondary);
            font-size: 0.95rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
        }

        .sidebar-nav a:hover,
        .sidebar-nav a.active {
            background: #eff6ff;
            color: var(--primary-color);
            font-weight: 500;
        }

        .content h1 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }

        .content h2 {
            font-size: 1.8rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
        }

        .content h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
        }

        .content p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .content :not(pre)>code {
            background: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Menlo', monospace;
            color: #c7254e;
        }

        .content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }

        .content pre {
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }
    </style>
</head>

<body>
    <header>
        <div class="nav-container">
            <a href="index.html" class="logo">
                <img src="images/logo/lango5.svg" alt="LangGraphGo Logo">
                LangGraphGo
            </a>
            <ul class="nav-links">
                <li><a href="../showcases.html">Showcases</a></li>
                <li><a href="../docs.html" style="color: var(--primary-color);">Docs</a></li>
                <li><a href="../examples.html">Examples</a></li>
                <li><a href="../../docs/guide-rag.html">中文</a></li>
            </ul>
            <a href="https://github.com/smallnest/langgraphgo" target="_blank" class="btn-github">
                <i class="fab fa-github"></i> GitHub
            </a>
        </div>
    </header>

    <div class="doc-container">
        <aside class="sidebar">
            <ul class="sidebar-nav">
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="core-concepts.html">Core Concepts</a></li>
                <li><a href="guides.html" class="active">Guides</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li
                    style="margin-top: 1.5rem; font-size: 0.85rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;">
                    Topic Guides</li>
                <li><a href="guide-basics.html" style="padding-left: 1rem;">Basic Building Blocks</a></li>
                <li><a href="guide-stategraph-vs-messagegraph.html" style="padding-left: 1rem;">StateGraph vs
                        MessageGraph</a></li>
                <li><a href="guide-createagent-vs-createreactagent.html" style="padding-left: 1rem;">CreateAgent vs
                        CreateReactAgent</a></li>
                <li><a href="guide-prebuilt-agents.html" style="padding-left: 1rem;">Prebuilt Agents</a></li>
                <li><a href="guide-streaming.html" style="padding-left: 1rem;">Streaming</a></li>
                <li><a href="guide-memory-timetravel.html" style="padding-left: 1rem;">Memory & Time Travel</a></li>
                <li><a href="guide-advanced-features.html" style="padding-left: 1rem;">Advanced Features</a></li>
                <li><a href="guide-rag.html" class="active" style="padding-left: 1rem;">RAG Pipeline</a></li>
                <li><a href="guide-hitl.html" style="padding-left: 1rem;">Human in the Loop (HITL)</a></li>
                <li><a href="guide-multi-agent.html" style="padding-left: 1rem;">Multi-Agent Systems</a></li>
                <li><a href="guide-state-management.html" style="padding-left: 1rem;">State Management</a></li>
                <li><a href="guide-monitoring.html" style="padding-left: 1rem;">Monitoring & Debugging</a></li>
            </ul>
        </aside>
        <main class="content">
            <h1>RAG Pipeline (Retrieval-Augmented Generation)</h1>
            <p>Retrieval-Augmented Generation (RAG) is currently the mainstream paradigm for building
                knowledge-intensive AI applications. By combining retrieval systems with generative models, RAG solves
                the problems of outdated knowledge and hallucinations in LLMs. LangGraphGo provides an ideal framework
                for building complex, adaptive RAG pipelines.</p>

            <h2>1. Basic RAG Flow</h2>

            <h3>Background & Functionality</h3>
            <p>The simplest RAG flow is linear: User Question -> Retrieve Docs -> Build Prompt -> LLM Generate Answer.
                With LangGraphGo, we can encapsulate each step as a node to clearly express this flow.</p>

            <h3>Implementation Principle</h3>
            <p>We usually define a state Schema containing `Question`, `Documents`, `Answer`. The retrieval node fills
                `Documents`, and the generation node reads `Documents` and fills `Answer`.</p>

            <h3>Code Showcase</h3>
            <pre><code class="language-go">// 1. Define State
type RAGState struct {
    Question  string
    Documents []string
    Answer    string
}

// 2. Define Retrieval Node
func retrieve(ctx context.Context, state interface{}) (interface{}, error) {
    s := state.(RAGState)
    // Call vector database or search engine
    docs := vectorStore.Search(s.Question)
    s.Documents = docs
    return s, nil
}

// 3. Define Generation Node
func generate(ctx context.Context, state interface{}) (interface{}, error) {
    s := state.(RAGState)
    // Build Prompt with context
    prompt := fmt.Sprintf("Context: %v\nQuestion: %s", s.Documents, s.Question)
    // Call LLM
    ans := llm.Generate(prompt)
    s.Answer = ans
    return s, nil
}

// 4. Build Graph
g.AddNode("retrieve", retrieve)
g.AddNode("generate", generate)
g.AddEdge("retrieve", "generate")</code></pre>

            <h2>2. Adaptive RAG</h2>

            <h3>Background & Functionality</h3>
            <p>Basic RAG assumes every retrieval is perfect, which is often not true. Adaptive RAG introduces feedback
                loops: if retrieved documents are irrelevant, or the generated answer cannot answer the question, the
                Agent can choose to rewrite the query, re-retrieve, or refuse to answer.</p>
            <p>LangGraphGo's cyclic graph structure is perfect for implementing this self-correcting logic.</p>

            <h3>Implementation Principle</h3>
            <p>We introduce a "grading" node (which can be the LLM itself) to score the retrieval results or the final
                answer. Based on the score, use conditional edges to route back to previous steps.</p>

            <h3>Code Showcase: Grading & Retry</h3>
            <pre><code class="language-go">// Grading Node: Evaluate document relevance
func gradeDocuments(ctx context.Context, state interface{}) (interface{}, error) {
    // ... Let LLM judge if documents are relevant to the question ...
    // Return state containing grading result
}

// Routing Function
func checkRelevance(ctx context.Context, state interface{}) string {
    s := state.(RAGState)
    if s.RelevanceScore < 0.7 {
        return "rewrite_query" // Low relevance, rewrite query
    }
    return "generate" // High relevance, generate answer
}

// Build Adaptive Flow
g.AddNode("retrieve", retrieve)
g.AddNode("grade", gradeDocuments)
g.AddNode("rewrite", rewriteQuery)
g.AddNode("generate", generate)

g.AddEdge("retrieve", "grade")
g.AddConditionalEdge("grade", checkRelevance)
g.AddEdge("rewrite", "retrieve") // Loop: re-retrieve after rewrite</code></pre>

            <h2>3. Corrective RAG (CRAG)</h2>
            <p>CRAG is an advanced pattern where if retrieved knowledge is unreliable, it falls back to Web Search to
                get the latest information. This can be easily implemented by adding a Web Search node and corresponding
                conditional routing in the graph.</p>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="../../script.js"></script>
</body>

</html>