<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基础构建块指南 - LangGraphGo 文档</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.cn/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.cn/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }

        .doc-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 120px 2rem 4rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 3rem;
        }

        .sidebar {
            position: sticky;
            top: 120px;
            height: fit-content;
        }

        .sidebar-nav {
            list-style: none;
        }

        .sidebar-nav li {
            margin-bottom: 0.5rem;
        }

        .sidebar-nav a {
            color: var(--text-secondary);
            font-size: 0.95rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
        }

        .sidebar-nav a:hover,
        .sidebar-nav a.active {
            background: #eff6ff;
            color: var(--primary-color);
            font-weight: 500;
        }

        .content h1 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }

        .content h2 {
            font-size: 1.8rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
        }

        .content h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
        }

        .content p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .content :not(pre)>code {
            background: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Menlo', monospace;
            color: #c7254e;
        }

        .content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }

        .content pre {
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }
    </style>
</head>

<body>
    <header>
        <div class="nav-container">
            <a href="index.html" class="logo">
                <img src="images/logo/lango5.svg" alt="LangGraphGo Logo">
                LangGraphGo
            </a>
            <ul class="nav-links">
                <li><a href="../showcases.html">案例</a></li>
                <li><a href="../docs.html" style="color: var(--primary-color);">文档</a></li>
                <li><a href="../examples.html">示例</a></li>
                <li><a href="../en/docs/guide-basics.html">English</a></li>
            </ul>
            <a href="https://github.com/smallnest/langgraphgo" target="_blank" class="btn-github">
                <i class="fab fa-github"></i> GitHub
            </a>
        </div>
    </header>

    <div class="doc-container">
        <aside class="sidebar">
            <ul class="sidebar-nav">
                <li><a href="getting-started.html">快速开始</a></li>
                <li><a href="core-concepts.html">核心概念</a></li>
                <li><a href="guides.html" class="active">指南</a></li>
                <li><a href="api.html">API 参考</a></li>
                <li
                    style="margin-top: 1.5rem; font-size: 0.85rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;">
                    专题指南</li>
                <li><a href="guide-basics.html" class="active" style="padding-left: 1rem;">基础构建块</a></li>
                <li><a href="guide-stategraph-vs-messagegraph.html" style="padding-left: 1rem;">StateGraph vs
                        MessageGraph</a></li>
                <li><a href="guide-createagent-vs-createreactagent.html" style="padding-left: 1rem;">CreateAgent vs
                        CreateReactAgent</a></li>
                <li><a href="guide-prebuilt-agents.html" style="padding-left: 1rem;">预构建 Agent</a></li>
                <li><a href="guide-streaming.html" style="padding-left: 1rem;">流式传输</a></li>
                <li><a href="guide-memory-timetravel.html" style="padding-left: 1rem;">记忆与时间旅行</a></li>
                <li><a href="guide-advanced-features.html" style="padding-left: 1rem;">高级特性</a></li>
                <li><a href="guide-rag.html" style="padding-left: 1rem;">RAG 管道</a></li>
                <li><a href="guide-hitl.html" style="padding-left: 1rem;">人工介入 (HITL)</a></li>
                <li><a href="guide-multi-agent.html" style="padding-left: 1rem;">多 Agent 系统</a></li>
                <li><a href="guide-state-management.html" style="padding-left: 1rem;">状态管理</a></li>
                <li><a href="guide-monitoring.html" style="padding-left: 1rem;">监控与调试</a></li>
            </ul>
        </aside>
        <main class="content">
            <h1>基础构建块</h1>
            <p>构建强大的 AI 应用就像搭积木。LangGraphGo 提供了一套精简而强大的核心原语，让你能够灵活地编排复杂的逻辑。本指南将深入探讨这些基础构建块：节点、边和条件路由。</p>

            <h2>1. 节点 (Nodes)：执行单元</h2>

            <h3>背景与功能</h3>
            <p>在任何工作流系统中，"做什么"是最基本的问题。节点就是 LangGraphGo 中的执行单元，它们负责具体的计算任务。无论是调用大语言模型
                (LLM)、查询数据库、执行代码，还是简单的格式化数据，都是在节点中完成的。</p>
            <p>节点的设计理念是<strong>函数式</strong>和<strong>无状态</strong>（尽可能）。它们接收当前的状态作为输入，并返回状态的更新作为输出。这种设计使得节点易于测试、复用和并行化。
            </p>

            <h3>实现原理</h3>
            <p>在底层，节点被定义为一个接收 <code>context.Context</code> 和输入状态，返回输出状态和错误的函数。LangGraphGo 的运行时负责调度这些函数，处理并发，并管理状态的传递。
            </p>

            <h3>代码展示：集成 LLM</h3>
            <p>最常见的节点类型是调用 LLM。LangGraphGo 与 <code>langchaingo</code> 无缝集成，使得在节点中使用各种 LLM 变得非常简单。</p>
            <pre><code class="language-go">import (
    "context"
    "github.com/tmc/langchaingo/llms"
    "github.com/tmc/langchaingo/llms/openai"
)

// 定义一个调用 LLM 的节点函数
func callLLM(ctx context.Context, state interface{}) (interface{}, error) {
    // 1. 从状态中提取消息历史
    messages := state.([]llms.MessageContent)
    
    // 2. 初始化 LLM (通常在图构建外部初始化一次)
    model, err := openai.New()
    if err != nil {
        return nil, err
    }
    
    // 3. 调用 LLM 生成回复
    response, err := model.GenerateContent(ctx, messages)
    if err != nil {
        return nil, err
    }
    
    // 4. 返回新的消息，这将通过 Reducer 追加到状态中
    return append(messages, llms.TextParts("ai", response.Choices[0].Content)), nil
}

// 将节点添加到图中
g.AddNode("chatbot", callLLM)</code></pre>

            <h2>2. 边 (Edges)：控制流</h2>

            <h3>背景与功能</h3>
            <p>定义了"做什么"之后，我们需要定义"按什么顺序做"。边定义了节点之间的连接关系，即控制流。最简单的边是普通边，它表示确定的顺序执行。</p>
            <p>通过组合简单的边，你可以构建出复杂的有向无环图 (DAG) 甚至包含循环的图（Cyclic Graph），这对于实现 Agent 的循环推理（思考-行动-观察）至关重要。</p>

            <h3>实现原理</h3>
            <p>图的数据结构维护了一个邻接表。当一个节点执行完成时，运行时会查找该节点的出边，并将下游节点加入到执行队列中。如果一个节点有多个出边，下游节点将被并行调度。</p>

            <h3>代码展示</h3>
            <pre><code class="language-go">// 定义线性流程：A -> B -> C -> END
g.AddEdge("node_a", "node_b")
g.AddEdge("node_b", "node_c")
g.AddEdge("node_c", graph.END) // END 是一个特殊的虚拟节点，表示图执行结束</code></pre>

            <h2>3. 条件边 (Conditional Edges)：动态路由</h2>

            <h3>背景与功能</h3>
            <p>现实世界的逻辑往往不是线性的。Agent 需要根据 LLM 的输出、工具的执行结果或外部输入来动态决定下一步做什么。例如，如果 LLM 决定调用工具，则跳转到工具节点；如果 LLM 决定直接回复，则结束。
            </p>
            <p>条件边引入了<strong>路由逻辑</strong>。它允许在运行时检查状态，并根据检查结果选择下一个节点。</p>

            <h3>实现原理</h3>
            <p>条件边关联了一个<strong>路由函数</strong>。当源节点执行完毕后，运行时会调用这个路由函数。路由函数返回目标节点的名称（字符串）。运行时根据这个返回值，动态地将控制权交给相应的节点。</p>

            <h3>代码展示：工具调用路由</h3>
            <p>以下是一个经典的 ReAct 模式中的路由逻辑：检查 LLM 是否发出了工具调用请求。</p>
            <pre><code class="language-go">// 路由函数：决定下一步是执行工具还是结束
func routeToolOrEnd(ctx context.Context, state interface{}) string {
    messages := state.([]llms.MessageContent)
    lastMessage := messages[len(messages)-1]
    
    // 检查最后一条消息是否包含工具调用
    if len(lastMessage.ToolCalls) > 0 {
        return "tools" // 跳转到工具执行节点
    }
    return graph.END // 否则结束
}

// 添加条件边
// 从 "llm_node" 出发，根据 routeToolOrEnd 的返回值决定去向
g.AddConditionalEdge("llm_node", routeToolOrEnd)

// 可选：显式定义路径映射，有助于可视化和验证
g.AddConditionalEdge("llm_node", routeToolOrEnd, map[string]string{
    "tools": "tools",
    graph.END: graph.END,
})</code></pre>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="../script.js"></script>
</body>

</html>